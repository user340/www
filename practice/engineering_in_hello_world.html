<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<title>e-yuuki.org</title>
</head>
<body>
<article class="tiny">
<h1>Hello Worldからつかむソフトウェアエンジニアリング</h1>
<p style="text-align:right;">2022年月日 初稿</p>
<figure>
<blockquote>
我々が提案するのは、「ソフトウェアエンジニアリング」とは単にコードを書く行為のみならず、組織が時間の経過に応じてコードを構築し保守するために用いるツールとプロセス全てをも包含するということである。
</blockquote>
<footer>&mdash;&mdash;<cite>Titus Winters, Tom Manshreck, Hyrum Wright 編 竹辺 靖昭 監訳 久富木 隆一 訳</cite>, <cite>Googleのソフトウェアエンジニアリング</cite>, p.x</footer>
</figure>
<hr>
<ol>
  <li><a href="#software_engineering">ソフトウェアエンジニアリングとはなにか</a></li>
  <li><a href="#introduction">読み進めるための準備</a></li>
  <li><a href="#env">Hello Worldの開発環境・実行環境</a></li>
  <li><a href="#documentation">Hello Worldのドキュメンテーション</a></li>
  <li><a href="#vcs">Hello Worldを管理する&mdash;&mdash;バージョン管理システム</a></li>
  <li>Hello Worldをテストする</li>
  <li>Hello Worldのコードレビュー</li>
  <li>Hello Worldをリリースする&mdash;&mdash;パッケージングとコンテナ化</li>
  <li>Hello Worldをサポートする</li>
  <li>Hello Worldをメンテナンスする</li>
  <li>ビルドとリリースを自動化する</li>
  <li>Hello Worldのタスクを管理する</li>
  <li>Hello World開発システムを監視する</li>
</ol>

<h2 id="software_engineering">ソフトウェアエンジニアリングとはなにか</h2>

<h3>「ソフトウェアエンジニアリング」という言葉の意味</h3>

<p>「ソフトウェアエンジニアリング」と聞いて具体的にどのようなことをするのか想像できるでしょうか？あるいは「わたしはソフトウェアエンジニアです」と言われて、どのような仕事に携わっているのか理解できるでしょうか？</p>

<p>「ソフトウェア」はコンピュータが処理するプログラムを指します。コンピュータの電源を入れたあとで自動的に動くオペレーティングシステム（WindowsやmacOSなど)や、ユーザが入力装置（マウスやキーボードなど）経由でコンピュータに実行を命じるアプリケーション（Webブラウザや文書作成ツールなど）を思い浮かべてください。</p>

<p>エンジニアリング（engineering）を辞書（eow.alc.co.jp）で引くと「（自然科学の応用分野の）工学」あるいは「自然科学や数学を、人間の役に立つ実用的な分野（建築、設計、土木、機械、製造など）に応用したもの」とあります。したがって「ソフトウェアエンジニアリング」を辞書的に解釈するなら「ソフトウェアを実用的な分野に応用すること」となります。また「ソフトウェアエンジニア」はそのようなことをする人ということになります。</p>

<h3>「ソフトウェアエンジニアリング」と「プログラミング」</h3>

<p>いっぽうで「ソフトウェアエンジニア」がおこなう「ソフトウェアエンジニアリング」は「プログラマ」がおこなう「プログラミング」とどのように区別されるのか疑問を抱くかもしれません。「ソフトウェアエンジニアリング」をテーマにした3つの書籍からこの言葉の意味を探っていきましょう。</p>

<p>『Googleのソフトウェアエンジニアリング』においてTitus Wintersは「我々の見るところ、プログラミングとソフトウェアエンジニアリングの決定的な違いは3つある。時間、スケール、そして作用しているトレードオフだ」（p.3）とし、「プログラミングは、コードを生産する即時的行動である。ソフトウェアエンジニアリングとは、コードを利用しなければならない期間中に有用に保つのに必要であり、またチームを横断した共同作業を可能とする、ポリシー、プラクティス、ツールのセットである」（p.29）と論じています。</p>

<p>また『モダン・ソフトウェアエンジニアリング』においてIvar Jacobsonらはソフトウェア開発プロジェクトが持つ複雑さに着目し「このような複雑さに対応する唯一の方法は、テスト、デプロイ、バージョン管理、構成管理など、目的に応じた専用のツールを使用することである」（p.13）としたうえで「ソフトウェアエンジニアリングとは、ソフトウェアの開発、テスト、デプロイ、運用、保守において、体系的で規律のある定量可能なアプローチを適用するものである」（p.13）と示しています。</p>

<p>最後に『実践ソフトウェアエンジニアリング [第9版]』においてRoger S. PressmanとBruce R. MaximはIEEE/ISO/IEC 24765-2017の『ISO/IEC/IEEE International Standard - Systems and software engineering -- Vocabulary』から「ソフトウェアエンジニアリング：ソフトウェアの開発、運用、メンテナンスに対するシステマティックで規律(discipline)ある、定量化できるアプローチの適用、すなわちソフトウェアに対するエンジニアリングの適用」（p.7）という定義を引用したのちに、「品質に焦点を合わせること(quality focus)」（p.7）を基盤として、下から順にプロセス・手法・ツールという階層構造がソフトウェアエンジニアリングに含まれていることを指摘しています。</p>

<!--
  IEEE/ISO/IEC 24765-2017 ISO/IEC/IEEE International Standard - Systems and software engineering -- Vocabulary
  https://standards.ieee.org/ieee/24765/6800/
-->

<p>つまりソフトウェアエンジニアリングは単にエンジニアがコードを書くというだけに留まらず、チームが一丸となってそのコードを長い期間安定して保守していくために必要な活動すべてを指しているということです。</p>

<h3>本稿のねらい</h3>

<p>本稿はプログラミングを習ったことのある人誰もが一度は見たことがあるHello Worldのコードをもとに、Hello Worldプログラムに対してどのようなソフトウェアエンジニアリングが実践できるのかをテーマとしています。プログラミングの技法については言及しません。またHello Worldにしてはおおげさな前提や仮定も恐れずに使います。Hello Worldをなにか別の立派なプロダクトに置き換えたときでも、本稿の内容が違わず実践できるようにするためです。</p>

<p>本稿ではプラクティスの実践にさいし特定のアプリケーションを使って説明をします。バージョン管理ならGit、パッケージングならRPMといったようにです。未来のことは誰にもわからないので、時が経つにつれ名前が変わったり時代遅れになったり開発プロジェクトそのものが解散するアプリケーションもなくはないでしょう。しかしバージョン管理やパッケージ管理システムという概念そのものがなくなることはおそらくないと見込んで、執筆時点でメジャーなアプリケーションを例にプラクティスを説明していきます。</p>

<p>また本稿はページ最下部にもあるとおりCC0、つまりパブリック・ドメインライセンスのもとに公開します。営利／非営利を問わず複製・改変・翻案・再頒布に対し著者の許可を得る必要はありません。</p>

<p>本文は予告なく変更されます。変更履歴等は明記しません。</p>

<h3>まとめ</h3>

<p>ソフトウェアエンジニアリングの定義はさまざまです。簡単に説明すると、単にプログラミングをしてソースコードを書き上げるだけに留まらず、そのソフトウェアが寿命を迎えるまでにおこなわなければならないあらゆる行動に対して定量的かつ規律ある手法を適用していく活動です。</p>

<p>本稿ではHello Worldのプログラムを通じてソフトウェアエンジニアリングの実践を試みます。</p>

<h3>より理解を深めるために</h3>

<ul>
  <li>『<b>Googleのソフトウェアエンジニアリング</b>』Titus Winters、Tom Manshreck、Hyrum Wright 編、竹辺 靖昭 監訳、久富木 隆一 訳（O'reilly Japan、2021年）</li>
  <li>『<b>モダン・ソフトウェアエンジニアリング</b>』Ivar Jacobson、Harold "Bud" Lawson、Pan-Wei Ng、Paul E. McMahon、Michael Goedicke 著、角 征典 訳、鷲崎 弘宜 監修（翔泳社、2020年）</li>
  <li>『<b>実践ソフトウェアエンジニアリング [第9版]</b>』Roger S. Pressman、Bruce R. Maxim 共著、SEPA翻訳プロジェクト 訳（オーム社、2021年）</li>
</ul>

<h2 id="prepare">読み進めるための準備</h2>

<h3>Red Hat Enterprise Linux 9のインストール</h3>

<p>本稿を読み、その内容を実践するにはLinuxディストリビューション、特にRed Hat Enterprise Linux 9（RHEL9）系のOSを実行できる環境が必要です。RHELクローンのOSやそれ以外の環境でも構いませんが環境の違いによる実行コマンドの差異などは自身で埋めてください。</p>

<p>RHEL9を利用するには、Red Hatアカウントを作成してRHEL 9のインストールISOをダウンロードします。RHEL9は個人利用なら最大16台まで無料でアップデートリポジトリにアクセスできます。任意の環境でインストーラーを起動したあと、Red Hatアカウントかアクティベーションキーのいずれかを使ってサブスクリプションに登録しインストールをおこないます。インストールの詳しい手順は割愛します。</p>

<!-- どのような環境が必要か。 エディタやターミナルの準備 -->

<h3>仮想環境を使う</h3>

<p>余っているPCや中古の安価なPCを使ってディスクへ直接RHEL9をインストールしても構いませんが、仮想マシンを使うことでホストOSとは独立した環境を用意できます。これに関する導入手順などは同じく割愛します。</p>

<p>Windowsを使っている場合はHyper-V、Linuxディストリビューションを使っている場合はQEMU/KVMが仮想マシンを提供する仮想化プラットフォームとしてポピュラーなものです。macOSでのtype1ハイパーバイザーがなにか筆者は分かりませんが、type2ならVirtualBoxはmacOS用のパッケージを提供しているようです。</p>

<h3>まとめ</h3>

<p>本稿を読み進めるためには任意の環境にRHEL 9 OSのインストールが必要です。RHEL 9は個人利用ならRed Hatのアカウントを作成すると無償で利用可能です。</p>

<h2 id="env">Hello Worldの開発環境・実行環境</h2>

<h3>ディレクトリ構造</h3>

<p>任意の場所に<code>engineering_in_hello_world</code>というディレクトリを作成してください。特に明記しない限り、以降はこのディレクトリの中でファイルを作ったりコマンドを実行したりするものとします。</p>

<pre><code><b class="user">mkdir engineering_in_hello_world</b>
<b class="user">cd engineering_in_hello_world</b></code></pre>

<h3>ソースコードとコンパイル</h3>

<p>以下のようなC言語のHello Worldを使います。<code>main.c</code>というファイルに書くものとします。このコードはこれ以上変更されません。<code>nano</code>などのテキストエディタを使ってこのコードをそのまま写してください。</p>

<pre><code>#include &lt;stdio.h&gt;

int
main(void)
{
        printf("Hello World\n");

        return 0;
}
</code></pre>

<p>このファイルを用意したあとC言語のコンパイラをインストールします。ここではGNU Cコンパイラを使います。</p>

<pre><code><b class="user">sudo dnf install gcc -y</b></code></pre>

<p>このコードをコンパイルするにはターミナルで<code>gcc</code>コマンドにコンパイルするファイル名を渡して実行します。コンパイルに成功するとカレントディレクトリに<code>a.out</code>というファイルが生成さます。それを実行すると次のように"Hello World"という文字列がターミナルに表示されます。</p>

<pre><code><b class="user">gcc main.c</b>
<b class="user">./a.out</b>
Hello World
</code></pre>

<p>これで画面に"Hello World"と表示するソフトウェアが出来上がりました。</p>

<p><code>a.out</code>ではなにをするソフトウェアなのか名前で判別できません。そこで<code>gcc</code>の<code>-o</code>オプションを使い、名前を指定してバイナリを生成するようにします。<code>a.out</code>は削除します。</p>

<pre><code><b class="user">rm ./a.out</b>
<b class="user">gcc main.c -o hello_world</b>
<b class="user">./hello_world</b>
Hello World
</code></pre>

<h3>Makefileによるビルドの自動化</h3>

<p>ここでは<code>main.c</code>ひとつしかソースコードのファイルがありませんが、現実に利用される大規模なソフトウェアのソースコードは機能や役割ごとにソースコードのファイルやファイルを配置するディレクトリが分割されています。</p>

<p>ソフトウェア全体をコンパイルするとき、毎回<code>gcc</code>コマンドにコンパイルすべきファイル名をすべて渡して実行するのは非効率です。また、それぞれのソースコードをコンパイルする前にソースコードの静的検査やユニットテストなど事前に動かしておきたいタスクもあります。コンパイルして生成されたバイナリファイルを削除したい場合もあるでしょう。</p>

<p>このようにただコンパイラを実行してソフトウェアをコンパイルするだけでなく、その前後になにかしらのタスクを挟むプロセスを本稿では<b>ビルド</b>と呼ぶことにします。C言語のみならずコンパイラを呼び出してソースコードをコンパイルするタイプのプログラミング言語に対しては、<code>make</code>コマンドとMakefileというファイルを用意すると便利です。</p>

<p>まずは<code>make</code>コマンドを使うためにそのパッケージをインストールします。</p>

<pre><code><b class="user">sudo dnf install make -y</b></code></pre>

<p>ファイル<code>Makefile</code>に次の内容を書きます。Makefileの場合、インデントはスペースではなくタブでなければなりません。</p>

<pre><code>NAME=     hello_world
PROGRAM=  main.c

all: build

build: ${NAME}

${NAME}: ${PROGRAM}
        gcc ${PROGRAM} -o $@

clean:
        rm -f ./${NAME}
</code></pre>

<p>1行目では変数<code>NAME</code>に<code>hello_world</code>を代入し変数定義しています。<code>hello_world</code>という文字列はこのファイルの中で合計3箇所使われるため、このように変数化することでコードの重複を避けています。Makefileでは、変数は<code>${NAME}</code>のように書くことで参照されます。したがってこのように書いてある箇所はすべて<code>hello_world</code>と書いてあるんだと解釈してください。同様に、<code>main.c</code>という文字列も複数ヶ所書くことから変数<code>PROGRAM</code>にまとめています。なお、変数定義しているところの空白はスペースではなくタブです。</p>

<p><code>all</code>や<code>build</code>、<code>clean</code>といったコロン（<code>:</code>）の前に書かれているものを<b>ターゲット</b>と呼びます。ターゲットのあとにファイル名が渡されているとき、そのターゲットと同じ名前のファイルが存在しない場合は次の行から続くタブ文字でインデントされたコマンドが1行ずつ実行されます。すでにそのターゲットと同じ名前のファイルが存在する場合は、ターゲットに渡されているファイルのタイムスタンプが更新されていない限りコマンドは実行されません。また、ターゲットにほかのターゲット名が渡されているときは、そのターゲットが順番に実行されます。</p>

<p>コマンドラインで<code>make</code>を実行したとき、<code>all:</code>のあとに渡されているターゲットが順番に実行されます。ここではまず<code>build</code>が実行され、<code>build</code>には<code>${NAME}</code>が渡されているため最終的には<code>${NAME}</code>ターゲット（<code>hello_world</code>ターゲット）が実行されます。カレントディレクトリにファイル<code>hello_world</code>が存在しないか、<code>main.c</code>のタイムスタンプが変更されていれば<code>gcc ${PROGRAM} -o $@</code>が動きます。</p>

<p>Makefileでは変数<code>$@</code>はターゲット名を参照します。つまりこのコマンドは最終的には<code>gcc main.c -o hello_world</code>と展開されます。</p>

<p><code>make clean</code>で<code>hello_world</code>を削除してから<code>make</code>コマンドを実行してみましょう。</p>

<pre><code><b class="user">make clean</b>
rm -f ./hello_world
<b class="user">make</b>
cc main.c -o hello_world
<b class="user">./hello_world</b>
Hello World</code></pre>

<p>もう一度<code>make</code>を実行すると、<code>main.c</code>にはなにも変更が加わっていないためコマンドはなにも実行されません。</p>

<pre><code><b class="user">make</b>
make: 'all' に対して行うべき事はありません.
</code></pre>

<h3>まとめ</h3>

<p>C言語のソースコードのコンパイル方法と、Makefileの簡単な文法について説明しました。現時点でディレクトリ<code>engineering_in_hello_world</code>は次のような構造になっているはずです。</p>

<pre><code>engineering_in_hello_world
├── hello_world
├── main.c
└── Makefile</code></pre>

<h3>より理解を深めるために</h3>

<ul>
  <li>『<b>プログラミング言語C</b>』Brian W. Kernighan、Dennis M. Ritchie 著、石田 晴久 訳（共立出版、1989年）</li>
  <li>『<b>GNU Make 第3版</b>』Robert Mecklenburg 著、矢吹 道郎 監訳、菊池 彰 訳（O'Reilly Japan、2005年）</li>
</ul>

<h2 id="documentation">Hello Worldのドキュメンテーション</h2>

<h3>ドキュメントの意義</h3>

<p>ここまででHello Worldプログラムを作り、そのビルドをMakefileで自動化することができました。次にやるべきことは、これまでに用意したファイル等について説明する<b>ドキュメント</b>を作るというものです。</p>

<p>なぜドキュメントを作らなければならないのでしょうか？ドキュメントは自分以外の誰かに対してビルドやソフトウェアを利用するための方法を説明したり、プロジェクトの意義や目的などを文章として残したりするために必要です。そして一般にソフトウェア開発は開発者一人だけでおこなわれずに、複数人がチームとして共同で作業することで達成されます。またソフトウェア開発プロジェクトが大規模になり時間がかかればかかるほど、戦力として新しくメンバーが参加する可能性もあります。</p>

<p>プライベートの時間で開発したソフトウェアならドキュメントは不要でしょうか？そうではありません。なぜなら人間はものごとを忘れる生き物だからです。そのソフトウェアに夢中になっているあいだは問題ないかもしれませんが、もし時間を空けて再度そのプロジェクトに取り掛かったりその成果物を使いたくなったたりしたときには、曖昧な記憶に頼るよりはドキュメントを読んだほうが手っ取り早いですし確実でしょう。</p>

<p>一方でドキュメンテーションはプログラミング等の作業と比べて優先順位が下がりがちな傾向にあります。アジャイルソフトウェア開発宣言（<a href="https://agilemanifesto.org/iso/ja/manifesto.html">https://agilemanifesto.org/iso/ja/manifesto.html</a>）では「包括的なドキュメントよりも動くソフトウェアを」という言葉もあります（これはドキュメントに価値がないという意味ではありません）。また Andrew HuntとDavid Thomasは『達人プログラマー』において「ほとんどの開発者はドキュメントのことについてあまり考えていません」（p.276）と断言しています。</p>

<p>ではドキュメンテーションは後回しにされて然るべきものなのでしょうか？違います。そのような実状を踏まえたうえでAndrewらは「我々はコードとドキュメントを分けるという考え方から離れ、それらを同じモデルの2つのビューとして扱うべきなのです。……（略）……すべてのドキュメントはコードを反映したものになっているはずです」（p.276）と述べ、もしドキュメントとソースコードとの間でなにかしらの矛盾があった場合は「どんな場合であれ、それはコードの問題へとつながっていくのです」と論じています。つまりドキュメンテーションはソースコードの問題を燻り出す可能性も秘めているのです。</p>

<h3>なにを書き残すべきか</h3>

<p>ドキュメンテーションのモチベーションをつかんだところで、現時点でのHello Worldプロジェクトでなにをドキュメントとして書き残すべきかを考えてみましょう。これまでおこなってきたことを列挙してみます。</p>

<ul>
  <li>RHEL9をインストールした。</li>
  <li>コンパイラと<code>make</code>のパッケージをインストールした。</li>
  <li>コンパイルして生成されたバイナリを実行した。</li>
</ul>

<p>これらがドキュメントとして残ってあれば、なにも知らない他の誰かがディレクトリを覗いたとしてもバイナリを実行できるところまでたどり着けるでしょう。</p>

<p>一般にドキュメントには、上記のような実行環境やビルド方法といったこと以外にも盛り込まれる内容があります。</p>

<ul>
  <li>プロジェクトの目的</li>
  <li>ソースコードのライセンス</li>
  <li>著者への連絡先</li>
  <li>寄付に関する情報</li>
  <li>スポンサーの一覧</li>
</ul>

<h3>Hello Worldのドキュメントを書く</h3>

<p>ここではプロジェクトの目的もドキュメントに記載することにします。</p>

<p>同じディレクトリの階層に<code>README</code>というファイルを作りそこにドキュメントを書いていきます。</p>

<pre><code>
Hello World -- Hello Worldを通じてソフトウェアエンジニアリングを学ぶためのプロジェクト

実行環境：

Red Hat Enterprise Linux 9

ビルド方法：

次のパッケージをインストールしてください。

- gcc
- make

ビルドするには次のように実行します。

make

実行方法：

./hello_world
</code></pre>

<p>もっとわかりやすい書き方や修飾の仕方があるかもしれませんが、ここではこのようにしておきます。</p>

<p>ドキュメントを書いたあとはそれを初めから終わりまで通読し書いてあるとおりの手順で書かれていることが実現できるかを確認してください。ドキュメントの量が多くなるほど、その執筆者による暗黙の了解や意図せず省略してしまった前提や手順などが紛れ込む可能性が高くなります。</p>

<p>ここまでで<code>engineering_in_hello_world</code>のディレクトリは次のようになっています。</p>

<pre><code>engineering_in_hello_world
├── hello_world
├── main.c
├── Makefile
└── README</code></pre>

<h3>より理解を深めるために</h3>

<ol>
  <li>『<b>新装版 達人プログラマー 職人から名匠への道</b>』Andrew Hunt、David Thomas 著、村上 雅章 訳（オーム社、2016年）</li>
</ol>

<h2 id="vcs">Hello Worldを管理する&mdash;&mdash;バージョン管理システム</h2>

<p>いままでに書いてきたソースコードやドキュメントはあなたの開発マシン上に残されています。このプロジェクトもあなたひとりだけのものです。</p>

<p>現実には、企業の中でおこなわれるソフトウェアプロジェクトには複数人の技術者が参画します。主語は「わたし」から「わたしたち」になるわけです。ここでは開発者ひとりひとりが互いに協同することによって製品が作り上げられていきます。つまり個人プレイからチームプレイへ移行するのです。</p>

<p>では複数人でこのHello Worldプロジェクトに取り掛かると仮定して、ひとりだけで取り組むときと比べてどのようなトラブルが発生するのか考えてみましょう。以下に軽く思いつくものを列挙しました。</p>

<ul>
  <li>変更記録を残しておかないと誰がなにをどのような意図でどう変更したのかわからなくなる。</li>
  <li>もし誰かが誤ったコードやドキュメントを書いたとき、バックアップがないと元通りにするのが面倒。</li>
  <li>ソースコードがひとりの開発マシンにしか存在しないので複数人でひとつのマシンを共有しないといけない。</li>
  <li>ひとりひとり好みのエディタやその設定が違うのでマシンを共有する場合は設定を調整したり各人に合わせた設定を別途用意する必要がある。</li>
</ul>

<p>これらのトラブルは「ソースコードの変更管理」と「共同作業」2つの問題に大別できます。それぞれの問題について個別の解決方法は確かに存在するでしょう。しかしソフトウェア開発という長い歴史の中でこれらの問題を一気に解決する技術が成熟してきました。それが「<b>バージョン管理システム</b>」（Version Control System）です。</p>
<hr>
<footer><div style="text-align:center;padding-top:2em;padding-bottom:2em;"><a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/"><img src="https://i.creativecommons.org/p/zero/1.0/88x31.png" alt="CC0" /></a></div><p>To the extent possible under law, <a href="mailto:uki@e-yuuki.org">Yuuki Enomoto</a> has waived all copyright and related or neighboring rights to e-yuuki.org. This work is published from: Japan.</p></footer></article></body></html>
