<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<title>e-yuuki.org</title>
</head>
<body>
<article class="tiny">
<h1>Hello Worldからつかむソフトウェアエンジニアリング</h1>
<p style="text-align:right;">2022年月日 初稿</p>
<figure>
<blockquote>
我々が提案するのは、「ソフトウェアエンジニアリング」とは単にコードを書く行為のみならず、組織が時間の経過に応じてコードを構築し保守するために用いるツールとプロセス全てをも包含するということである。
</blockquote>
<footer>&mdash;&mdash;<cite>Titus Winters, Tom Manshreck, Hyrum Wright 編 竹辺 靖昭 監訳 久富木 隆一 訳</cite>, <cite>Googleのソフトウェアエンジニアリング</cite>, p.x</footer>
</figure>
<hr>
<ol>
  <li><a href="#software_engineering">ソフトウェアエンジニアリングとはなにか</a></li>
  <li><a href="#introduction">読み進めるための準備</a></li>
  <li><a href="#env">Hello Worldの開発環境・実行環境</a></li>
  <li><a href="#documentation">Hello Worldのドキュメンテーション</a></li>
  <li><a href="#vcs">Hello Worldを管理する&mdash;&mdash;バージョン管理システム</a></li>
  <li><a href="#test">Hello Worldをテストする</a></li>
  <li>Hello Worldのコードレビュー</li>
  <li>Hello Worldをリリースする&mdash;&mdash;パッケージングとコンテナ化</li>
  <li>Hello Worldをサポートする</li>
  <li>Hello Worldをメンテナンスする</li>
  <li>ビルドとリリースを自動化する</li>
  <li>Hello Worldのタスクを管理する</li>
  <li>Hello World開発システムを監視する</li>
</ol>

<h2 id="software_engineering">ソフトウェアエンジニアリングとはなにか</h2>

<h3>「ソフトウェアエンジニアリング」という言葉の意味</h3>

<p>「ソフトウェアエンジニアリング」と聞いて具体的にどのようなことをするのか想像できるでしょうか？あるいは「わたしはソフトウェアエンジニアです」と言われて、どのような仕事に携わっているのか理解できるでしょうか？</p>

<p>「ソフトウェア」はコンピュータが処理するプログラムを指します。コンピュータの電源を入れたあとで自動的に動くオペレーティングシステム（WindowsやmacOSなど)や、ユーザが入力装置（マウスやキーボードなど）経由でコンピュータに実行を命じるアプリケーション（Webブラウザや文書作成ツールなど）を思い浮かべてください。</p>

<p>エンジニアリング（engineering）を辞書（eow.alc.co.jp）で引くと「（自然科学の応用分野の）工学」あるいは「自然科学や数学を、人間の役に立つ実用的な分野（建築、設計、土木、機械、製造など）に応用したもの」とあります。したがって「ソフトウェアエンジニアリング」を辞書的に解釈するなら「ソフトウェアを実用的な分野に応用すること」となります。また「ソフトウェアエンジニア」はそのようなことをする人ということになります。</p>

<h3>「ソフトウェアエンジニアリング」と「プログラミング」</h3>

<p>いっぽうで「ソフトウェアエンジニア」がおこなう「ソフトウェアエンジニアリング」は「プログラマ」がおこなう「プログラミング」とどのように区別されるのか疑問を抱くかもしれません。「ソフトウェアエンジニアリング」をテーマにした3つの書籍からこの言葉の意味を探っていきましょう。</p>

<p>『Googleのソフトウェアエンジニアリング』においてTitus Wintersは「我々の見るところ、プログラミングとソフトウェアエンジニアリングの決定的な違いは3つある。時間、スケール、そして作用しているトレードオフだ」（p.3）とし、「プログラミングは、コードを生産する即時的行動である。ソフトウェアエンジニアリングとは、コードを利用しなければならない期間中に有用に保つのに必要であり、またチームを横断した共同作業を可能とする、ポリシー、プラクティス、ツールのセットである」（p.29）と論じています。</p>

<p>また『モダン・ソフトウェアエンジニアリング』においてIvar Jacobsonらはソフトウェア開発プロジェクトが持つ複雑さに着目し「このような複雑さに対応する唯一の方法は、テスト、デプロイ、バージョン管理、構成管理など、目的に応じた専用のツールを使用することである」（p.13）としたうえで「ソフトウェアエンジニアリングとは、ソフトウェアの開発、テスト、デプロイ、運用、保守において、体系的で規律のある定量可能なアプローチを適用するものである」（p.13）と示しています。</p>

<p>最後に『実践ソフトウェアエンジニアリング [第9版]』においてRoger S. PressmanとBruce R. MaximはIEEE/ISO/IEC 24765-2017の『ISO/IEC/IEEE International Standard - Systems and software engineering -- Vocabulary』から「ソフトウェアエンジニアリング：ソフトウェアの開発、運用、メンテナンスに対するシステマティックで規律(discipline)ある、定量化できるアプローチの適用、すなわちソフトウェアに対するエンジニアリングの適用」（p.7）という定義を引用したのちに、「品質に焦点を合わせること(quality focus)」（p.7）を基盤として、下から順にプロセス・手法・ツールという階層構造がソフトウェアエンジニアリングに含まれていることを指摘しています。</p>

<!--
  IEEE/ISO/IEC 24765-2017 ISO/IEC/IEEE International Standard - Systems and software engineering -- Vocabulary
  https://standards.ieee.org/ieee/24765/6800/
-->

<p>つまりソフトウェアエンジニアリングは単にエンジニアがコードを書くというだけに留まらず、チームが一丸となってそのコードを長い期間安定して保守していくために必要な活動すべてを指しているということです。</p>

<h3>本稿のねらい</h3>

<p>本稿はプログラミングを習ったことのある人誰もが一度は見たことがあるHello Worldのコードをもとに、Hello Worldプログラムに対してどのようなソフトウェアエンジニアリングが実践できるのかをテーマとしています。プログラミングの技法については言及しません。またHello Worldにしてはおおげさな前提や仮定も恐れずに使います。Hello Worldをなにか別の立派なプロダクトに置き換えたときでも、本稿の内容が違わず実践できるようにするためです。</p>

<p>本稿ではプラクティスの実践にさいし特定のアプリケーションを使って説明をします。バージョン管理ならGit、パッケージングならRPMといったようにです。未来のことは誰にもわからないので、時が経つにつれ名前が変わったり時代遅れになったり開発プロジェクトそのものが解散するアプリケーションもなくはないでしょう。しかしバージョン管理やパッケージ管理システムという概念そのものがなくなることはおそらくないと見込んで、執筆時点でメジャーなアプリケーションを例にプラクティスを説明していきます。</p>

<p>また本稿はページ最下部にもあるとおりCC0、つまりパブリック・ドメインライセンスのもとに公開します。営利／非営利を問わず複製・改変・翻案・再頒布に対し著者の許可を得る必要はありません。</p>

<p>本文は予告なく変更されます。変更履歴等は明記しません。</p>

<h3>まとめ</h3>

<p>ソフトウェアエンジニアリングの定義はさまざまです。簡単に説明すると、単にプログラミングをしてソースコードを書き上げるだけに留まらず、そのソフトウェアが寿命を迎えるまでにおこなわなければならないあらゆる行動に対して定量的かつ規律ある手法を適用していく活動です。</p>

<p>本稿ではHello Worldのプログラムを通じてソフトウェアエンジニアリングの実践を試みます。</p>

<h3>参考文献</h3>

<ul>
  <li>『<b>Googleのソフトウェアエンジニアリング</b>』Titus Winters、Tom Manshreck、Hyrum Wright 編、竹辺 靖昭 監訳、久富木 隆一 訳（O'reilly Japan、2021年）</li>
  <li>『<b>モダン・ソフトウェアエンジニアリング</b>』Ivar Jacobson、Harold "Bud" Lawson、Pan-Wei Ng、Paul E. McMahon、Michael Goedicke 著、角 征典 訳、鷲崎 弘宜 監修（翔泳社、2020年）</li>
  <li>『<b>実践ソフトウェアエンジニアリング [第9版]</b>』Roger S. Pressman、Bruce R. Maxim 共著、SEPA翻訳プロジェクト 訳（オーム社、2021年）</li>
</ul>

<h2 id="prepare">読み進めるための準備</h2>

<h3>Red Hat Enterprise Linux 9のインストール</h3>

<p>本稿を読み、その内容を実践するにはLinuxディストリビューション、特にRed Hat Enterprise Linux 9（RHEL9）系のOSを実行できる環境が必要です。RHELクローンのOSやそれ以外の環境でも構いませんが環境の違いによる実行コマンドの差異などは自身で埋めてください。</p>

<p>RHEL9を利用するには、Red Hatアカウントを作成してRHEL 9のインストールISOをダウンロードします。RHEL9は個人利用なら最大16台まで無料でアップデートリポジトリにアクセスできます。任意の環境でインストーラーを起動したあと、Red Hatアカウントかアクティベーションキーのいずれかを使ってサブスクリプションに登録しインストールをおこないます。インストールの詳しい手順は割愛します。</p>

<!-- どのような環境が必要か。 エディタやターミナルの準備 -->

<h3>仮想環境を使う</h3>

<p>余っているPCや中古の安価なPCを使ってディスクへ直接RHEL9をインストールしても構いませんが、仮想マシンを使うことでホストOSとは独立した環境を用意できます。これに関する導入手順などは同じく割愛します。</p>

<p>Windowsを使っている場合はHyper-V、Linuxディストリビューションを使っている場合はQEMU/KVMが仮想マシンを提供する仮想化プラットフォームとしてポピュラーなものです。macOSでのtype1ハイパーバイザーがなにか筆者は分かりませんが、type2ならVirtualBoxはmacOS用のパッケージを提供しているようです。</p>

<h3>まとめ</h3>

<p>本稿を読み進めるためには任意の環境にRHEL 9 OSのインストールが必要です。RHEL 9は個人利用ならRed Hatのアカウントを作成すると無償で利用可能です。</p>

<h2 id="env">Hello Worldの開発環境・実行環境</h2>

<h3>ディレクトリ構造</h3>

<p>任意の場所に<code>engineering_in_hello_world</code>というディレクトリを作成してください。特に明記しない限り、以降はこのディレクトリの中でファイルを作ったりコマンドを実行したりするものとします。</p>

<pre><code><b class="user">mkdir engineering_in_hello_world</b>
<b class="user">cd engineering_in_hello_world</b></code></pre>

<h3>ソースコードとコンパイル</h3>

<p>以下のようなC言語のHello Worldを使います。<code>main.c</code>というファイルに書くものとします。このコードはこれ以上変更されません。<code>nano</code>などのテキストエディタを使ってこのコードをそのまま写してください。</p>

<pre><code>#include &lt;stdio.h&gt;

int
main(void)
{
        printf("Hello World\n");

        return 0;
}
</code></pre>

<p>このファイルを用意したあとC言語のコンパイラをインストールします。ここではGNU Cコンパイラを使います。</p>

<pre><code><b class="user">sudo dnf install gcc -y</b></code></pre>

<p>このコードをコンパイルするにはターミナルで<code>gcc</code>コマンドにコンパイルするファイル名を渡して実行します。コンパイルに成功するとカレントディレクトリに<code>a.out</code>というファイルが生成さます。それを実行すると次のように"Hello World"という文字列がターミナルに表示されます。</p>

<pre><code><b class="user">gcc main.c</b>
<b class="user">./a.out</b>
Hello World
</code></pre>

<p>これで画面に"Hello World"と表示するソフトウェアが出来上がりました。</p>

<p><code>a.out</code>ではなにをするソフトウェアなのか名前で判別できません。そこで<code>gcc</code>の<code>-o</code>オプションを使い、名前を指定してバイナリを生成するようにします。<code>a.out</code>は削除します。</p>

<pre><code><b class="user">rm ./a.out</b>
<b class="user">gcc main.c -o hello_world</b>
<b class="user">./hello_world</b>
Hello World
</code></pre>

<h3>Makefileによるビルドの自動化</h3>

<p>ここでは<code>main.c</code>ひとつしかソースコードのファイルがありませんが、現実に利用される大規模なソフトウェアのソースコードは機能や役割ごとにソースコードのファイルやファイルを配置するディレクトリが分割されています。</p>

<p>ソフトウェア全体をコンパイルするとき、毎回<code>gcc</code>コマンドにコンパイルすべきファイル名をすべて渡して実行するのは非効率です。また、それぞれのソースコードをコンパイルする前にソースコードの静的検査やユニットテストなど事前に動かしておきたいタスクもあります。コンパイルして生成されたバイナリファイルを削除したい場合もあるでしょう。</p>

<p>このようにただコンパイラを実行してソフトウェアをコンパイルするだけでなく、その前後になにかしらのタスクを挟むプロセスを本稿では<b>ビルド</b>と呼ぶことにします。C言語のみならずコンパイラを呼び出してソースコードをコンパイルするタイプのプログラミング言語に対しては、<code>make</code>コマンドとMakefileというファイルを用意すると便利です。</p>

<p>まずは<code>make</code>コマンドを使うためにそのパッケージをインストールします。</p>

<pre><code><b class="user">sudo dnf install make -y</b></code></pre>

<p>ファイル<code>Makefile</code>に次の内容を書きます。Makefileの場合、インデントはスペースではなくタブでなければなりません。</p>

<pre><code>NAME=     hello_world
PROGRAM=  main.c

all: build

build: ${NAME}

${NAME}: ${PROGRAM}
        gcc ${PROGRAM} -o $@

clean:
        rm -f ./${NAME}
</code></pre>

<p>1行目では変数<code>NAME</code>に<code>hello_world</code>を代入し変数定義しています。<code>hello_world</code>という文字列はこのファイルの中で合計3箇所使われるため、このように変数化することでコードの重複を避けています。Makefileでは、変数は<code>${NAME}</code>のように書くことで参照されます。したがってこのように書いてある箇所はすべて<code>hello_world</code>と書いてあるんだと解釈してください。同様に、<code>main.c</code>という文字列も複数ヶ所書くことから変数<code>PROGRAM</code>にまとめています。なお、変数定義しているところの空白はスペースではなくタブです。</p>

<p><code>all</code>や<code>build</code>、<code>clean</code>といったコロン（<code>:</code>）の前に書かれているものを<b>ターゲット</b>と呼びます。ターゲットのあとにファイル名が渡されているとき、そのターゲットと同じ名前のファイルが存在しない場合は次の行から続くタブ文字でインデントされたコマンドが1行ずつ実行されます。すでにそのターゲットと同じ名前のファイルが存在する場合は、ターゲットに渡されているファイルのタイムスタンプが更新されていない限りコマンドは実行されません。また、ターゲットにほかのターゲット名が渡されているときは、そのターゲットが順番に実行されます。</p>

<p>コマンドラインで<code>make</code>を実行したとき、<code>all:</code>のあとに渡されているターゲットが順番に実行されます。ここではまず<code>build</code>が実行され、<code>build</code>には<code>${NAME}</code>が渡されているため最終的には<code>${NAME}</code>ターゲット（<code>hello_world</code>ターゲット）が実行されます。カレントディレクトリにファイル<code>hello_world</code>が存在しないか、<code>main.c</code>のタイムスタンプが変更されていれば<code>gcc ${PROGRAM} -o $@</code>が動きます。</p>

<p>Makefileでは変数<code>$@</code>はターゲット名を参照します。つまりこのコマンドは最終的には<code>gcc main.c -o hello_world</code>と展開されます。</p>

<p><code>make clean</code>で<code>hello_world</code>を削除してから<code>make</code>コマンドを実行してみましょう。</p>

<pre><code><b class="user">make clean</b>
rm -f ./hello_world
<b class="user">make</b>
cc main.c -o hello_world
<b class="user">./hello_world</b>
Hello World</code></pre>

<p>もう一度<code>make</code>を実行すると、<code>main.c</code>にはなにも変更が加わっていないためコマンドはなにも実行されません。</p>

<pre><code><b class="user">make</b>
make: 'all' に対して行うべき事はありません.
</code></pre>

<h3>まとめ</h3>

<p>C言語のソースコードのコンパイル方法と、Makefileの簡単な文法について説明しました。現時点でディレクトリ<code>engineering_in_hello_world</code>は次のような構造になっているはずです。</p>

<pre><code>engineering_in_hello_world
├── hello_world
├── main.c
└── Makefile</code></pre>

<h3>参考文献</h3>

<ul>
  <li>『<b>プログラミング言語C</b>』Brian W. Kernighan、Dennis M. Ritchie 著、石田 晴久 訳（共立出版、1989年）</li>
  <li>『<b>GNU Make 第3版</b>』Robert Mecklenburg 著、矢吹 道郎 監訳、菊池 彰 訳（O'Reilly Japan、2005年）</li>
</ul>

<h2 id="documentation">Hello Worldのドキュメンテーション</h2>

<h3>ドキュメントの意義</h3>

<p>ここまででHello Worldプログラムを作り、そのビルドをMakefileで自動化することができました。次にやるべきことは、これまでに用意したファイル等について説明する<b>ドキュメント</b>を作るというものです。</p>

<p>なぜドキュメントを作らなければならないのでしょうか？ドキュメントは自分以外の誰かに対してビルドやソフトウェアを利用するための方法を説明したり、プロジェクトの意義や目的などを文章として残したりするために必要です。そして一般にソフトウェア開発は開発者一人だけでおこなわれずに、複数人がチームとして共同で作業することで達成されます。またソフトウェア開発プロジェクトが大規模になり時間がかかればかかるほど、戦力として新しくメンバーが参加する可能性もあります。</p>

<p>プライベートの時間で開発したソフトウェアならドキュメントは不要でしょうか？そうではありません。なぜなら人間はものごとを忘れる生き物だからです。そのソフトウェアに夢中になっているあいだは問題ないかもしれませんが、もし時間を空けて再度そのプロジェクトに取り掛かったりその成果物を使いたくなったたりしたときには、曖昧な記憶に頼るよりはドキュメントを読んだほうが手っ取り早いですし確実でしょう。</p>

<p>一方でドキュメンテーションはプログラミング等の作業と比べて優先順位が下がりがちな傾向にあります。アジャイルソフトウェア開発宣言（<a href="https://agilemanifesto.org/iso/ja/manifesto.html">https://agilemanifesto.org/iso/ja/manifesto.html</a>）では「包括的なドキュメントよりも動くソフトウェアを」という言葉もあります（これはドキュメントに価値がないという意味ではありません）。また Andrew HuntとDavid Thomasは『達人プログラマー』において「ほとんどの開発者はドキュメントのことについてあまり考えていません」（p.276）と断言しています。</p>

<p>ではドキュメンテーションは後回しにされて然るべきものなのでしょうか？違います。そのような実状を踏まえたうえでAndrewらは「我々はコードとドキュメントを分けるという考え方から離れ、それらを同じモデルの2つのビューとして扱うべきなのです。……（略）……すべてのドキュメントはコードを反映したものになっているはずです」（p.276）と述べ、もしドキュメントとソースコードとの間でなにかしらの矛盾があった場合は「どんな場合であれ、それはコードの問題へとつながっていくのです」と論じています。つまりドキュメンテーションはソースコードの問題を燻り出す可能性も秘めているのです。</p>

<h3>なにを書き残すべきか</h3>

<p>ドキュメンテーションのモチベーションをつかんだところで、現時点でのHello Worldプロジェクトでなにをドキュメントとして書き残すべきかを考えてみましょう。これまでおこなってきたことを列挙してみます。</p>

<ul>
  <li>RHEL9をインストールした。</li>
  <li>コンパイラと<code>make</code>のパッケージをインストールした。</li>
  <li>コンパイルして生成されたバイナリを実行した。</li>
</ul>

<p>これらがドキュメントとして残ってあれば、なにも知らない他の誰かがディレクトリを覗いたとしてもバイナリを実行できるところまでたどり着けるでしょう。</p>

<p>一般にドキュメントには、上記のような実行環境やビルド方法といったこと以外にも盛り込まれる内容があります。</p>

<ul>
  <li>プロジェクトの目的</li>
  <li>ソースコードのライセンス</li>
  <li>著者への連絡先</li>
  <li>寄付に関する情報</li>
  <li>スポンサーの一覧</li>
</ul>

<h3>Hello Worldのドキュメントを書く</h3>

<p>ここではプロジェクトの目的もドキュメントに記載することにします。</p>

<p>同じディレクトリの階層に<code>README</code>というファイルを作りそこにドキュメントを書いていきます。</p>

<pre><code>
Hello World -- Hello Worldを通じてソフトウェアエンジニアリングを学ぶためのプロジェクト

実行環境：

Red Hat Enterprise Linux 9

ビルド方法：

次のパッケージをインストールしてください。

- gcc
- make

ビルドするには次のように実行します。

make

実行方法：

./hello_world
</code></pre>

<p>もっとわかりやすい書き方や修飾の仕方があるかもしれませんが、ここではこのようにしておきます。</p>

<p>ドキュメントを書いたあとはそれを初めから終わりまで通読し書いてあるとおりの手順で書かれていることが実現できるかを確認してください。ドキュメントの量が多くなるほど、その執筆者による暗黙の了解や意図せず省略してしまった前提や手順などが紛れ込む可能性が高くなります。</p>

<p>ここまでで<code>engineering_in_hello_world</code>のディレクトリは次のようになっています。</p>

<pre><code>engineering_in_hello_world
├── hello_world
├── main.c
├── Makefile
└── README</code></pre>

<h3>参考文献</h3>

<ul>
  <li>『<b>新装版 達人プログラマー 職人から名匠への道</b>』Andrew Hunt、David Thomas 著、村上 雅章 訳（オーム社、2016年）</li>
</ul>

<h2 id="vcs">Hello Worldを管理する&mdash;&mdash;バージョン管理システム</h2>

<h3>個人プレイからチームプレイへ</h3>

<p>いままでに書いてきたソースコードやドキュメントはあなたの開発マシン上に残されています。このプロジェクトもあなたひとりだけのものです。</p>

<p>現実には、企業の中でおこなわれるソフトウェアプロジェクトには複数人の技術者が参画します。主語は「わたし」から「わたしたち」になるわけです。ここでは開発者ひとりひとりが互いに協同することによって製品が作り上げられていきます。つまり個人プレイからチームプレイへ移行するのです。</p>

<p>では複数人でこのHello Worldプロジェクトに取り掛かると仮定して、ひとりだけで取り組むときと比べてどのようなトラブルが発生するのか考えてみましょう。以下に軽く思いつくものを列挙しました。</p>

<ul>
  <li>変更記録を残しておかないと誰がなにをどのような意図でどう変更したのかわからなくなる。</li>
  <li>もし誰かが誤ったコードやドキュメントを書いたとき、バックアップがないと元通りにするのが面倒。</li>
  <li>ソースコードがひとりの開発マシンにしか存在しないので複数人でひとつのマシンを共有しないといけない。</li>
  <li>ひとりひとり好みのエディタやその設定が違うのでマシンを共有する場合は設定を調整したり各人に合わせた設定を別途用意する必要がある。</li>
</ul>

<p>これらのトラブルは「ソースコードの変更管理」と「共同作業」2つの問題に大別できます。それぞれの問題について個別の解決方法は確かに存在するでしょう。しかしソフトウェア開発という長い歴史の中でこれらの問題を一気に解決する技術が成熟してきました。それが「<b>バージョン管理システム</b>」（Version Control System）です。</p>

<h3>バージョン管理システム（VCS）とは</h3>

<p>「バージョン管理システム（VCS）」について、Chaconらは「バージョン管理とは、一つのファイルやファイルの集合に対して時間とともに加えられていく変更を記録するシステムで、後で特定バージョンを呼び出すことができるようにするためのものです」（p.25）と説明しています。つまりバージョン管理システムを使うことでどのファイルがいつ・どのように・誰によって追加・変更・削除されたのかを常に追跡できるようになります。</p>

<p>不特定多数のプログラマが同じコードツリーを編集するにあたり求められてきたVCSには長い歴史があります。Fogelらが示すように<code>diff</code>と<code>patch</code>による電子メール経由での変更から始まり、Revision Control System（RCS）・Concurrent Versions System（CVS）・Apache Subversion（SVN）・Bitkeeper・MercurialおよびGitといったさまざまなVCSが登場しました。これらツールがそれぞれ機能的・ライセンス的にどのように異なり使い勝手が違うのかといった調査は読者に任せますが、機能や使い勝手に対する利用者のニーズ・ツールそのもののデザインに対する考え方・利用規約・そのVCSを利用できるWebプラットフォームなどさまざまな要素が時代によって変遷していき今に至ったことは確かです。</p>

<p>現在では<a href="https://github.com">GitHub</a>や<a href="https://gitlab.com">GitLab</a>といったGitをベースとしたソースコード管理サービスが世界的に使われていることもあり、本稿ではVCSとしてGitをHello Worldプロジェクトに導入することにします。ただし本稿はGitHubやGitLabといったWebサービスの利用方法については触れません。</p>

<p>また本稿ではVCSで管理されたソースツリーのことを「リポジトリ」と呼ぶことにします。世間一般にも通じる呼び方でしょう。</p>

<h3>集中型VCSと分散型VCS</h3>

<p>VCSには大きく集中型のものと分散型の2つに分けられます。CVSやSVNといった集中型のVCSでは、ひとつの中央リポジトリにそれぞれの開発者がネットワーク経由で変更を加えていきます。開発者はリポジトリからソースコードなどのファイルをコピー（チェックアウト）し、それに変更を加えたあとにコミットすることで中央に変更が反映されます。ソースコードの変更履歴を知りたいときはその中央リポジトリをホスティングしているサーバまでネットワーク経由で問い合わせをしなければなりません。</p>

<p>一方GitやMercurialといった分散型のVCSでは集中型のVCSと同じく主となるリポジトリは存在しますが、集中型と異なりそれぞれの開発者が完全な履歴を含めたリポジトリのコピーを手元のマシンにチェックアウトできます。集中型VCSにおけるコミットはネットワークを通した中央リポジトリへの変更反映でしたが、分散型VCSのコミットは開発者のマシンに存在するチェックアウトしてきたリポジトリ&mdash;&mdash;ローカルリポジトリ&mdash;&mdash;への変更反映です。</p>

<p>分散型VCSでローカルリポジトリへコミットしたあと主のリポジトリへ同じコミットを反映させるには、そのリポジトリへ変更をプッシュするか、そのリポジトリを変更する権限があるユーザにお願いしてそのコミットをマージしてもらいます。集中型VCSと比べると煩雑に思えるかもしれません。ただ現代のソフトウェア開発の現場では、開発者がコミットし、権限を持つ別の開発者がそのコミット内容をレビューしマージするという分散型VCSを前提とした開発フローが一般的になっています。</p>

<h3>Git</h3>

<h4>Gitのインストール</h4>

<p>さて、実際に分散型VCSのGitを使ってみましょう。GitはGNU General Public License version 2.0でライセンスされたオープンソースのVCSです。2005年12月に初版がリリースされて以来、GitHubなどWeb上の高機能なホスティングサービスも相まって現在に至るまで全世界のソフトウェア開発者に利用されています。</p>

<p>RHEL9では<code>git</code>パッケージでGitが提供されています。インストールするにはターミナルで次のように実行します。</p>

<pre><code><b class="root">dnf install git -y</b></code></pre>

<h4>Gitリポジトリの初期化とリポジトリへのコミット</h4>

<p>いままで作業してきたソースツリー<code>engineering_in_hello_world</code>をGitリポジトリ化しましょう。このディレクトリまで移動して次のように実行してください。</p>

<pre><code><b class="user">git init</b></code></pre>

<p>次はリポジトリへコミットしていきます。Gitでは次の手順でコミットします。</p>

<ol>
  <li><code>git add</code>コマンドでファイルをステージングする。</li>
  <li><code>git commit</code>コマンドでステージングされたファイルをコミットする。</li>
</ol>

<p>まずは<code>main.c</code>からコミットします。</p>

<pre><code><b class="user">git add main.c</b>
<b class="user">git commit</b></code></pre>

<p>ここで<code>git commit</code>したとき、自動的にテキストエディタの画面が開かれます。ここでコミットメッセージを書き保存してエディタを閉じることでコミットが完了します。行頭が<code>#</code>から始まる行はコメントとして扱われ、実際のコミットメッセージには含まれません。コミットメッセージに関するルールや文化はプロジェクトごとに異なります。ここでは最低限の形式を提示します。</p>

<pre><code>
1  コミットの概要（1行）
2  ＜空行＞
3  コミット内容の詳細な説明が続く……
4  …
5  …
</code></pre>

<p>左端の数字はテキストの行番号を示しています。コミットメッセージの1行目にはそのコミットの概要を1行で書いてください。コミットメッセージは最低1行からなのでこの時点でもコミットは可能ですが、どのような経緯で変更に至ったかなどを書くためにだいたいは1行では済みません。</p>

<p>1行目の概要以外にもコミットメッセージを記述する場合、2行目はなにも書かない空の行にし、3行目以降にコミット内容の詳細な説明を記述していってください。Hello Worldプロジェクトの<code>main.c</code>をコミットするときのコミットメッセージの例は以下のとおりです。</p>

<pre><code>Hello Worldソースコードを作成した

ソフトウェアエンジニアリングを体験するためにHello Worldのソースコードを
Gitリポジトリにコミットした。
</code></pre>

<p>このようにコミットメッセージを書いて、内容を保存したあとにエディタを終了してください。エディタの画面からシェルのプロンプトに戻り<code>git commit</code>コマンドが完了します。コミットの履歴を確認するには<code>git log</code>コマンドを使います。さきほどのコミットが正常にリポジトリへ反映されているかどうかを確認しましょう。</p>

<pre><code><b class="user">git log</b>
commit e83915907a4ed415a0991c34e8df0b5f20112bd5 (HEAD -> master)
Author: Yuuki Enomoto <uki@localhost.localdomain>
Date:   Thu Sep 29 21:17:48 2022 +0900

    Hello Worldソースコードを作成した

    ソフトウェアエンジニアリングを体験するためにHello Worldのソースコードを
    Gitリポジトリにコミットした。
</code></pre>

<p>続いて<code>Makefile</code>や<code>README</code>も同じようにコミットしていきます。これらのファイルは役割が違いますし同時に作ったわけでもありません。別々のコミットに分けてしまいましょう。コミットメッセージをどう書くかはお任せします。</p>

<pre><code><b class="user">git add Makefile</b>
<b class="user">git commit</b>
<b class="user">git add README</b>
<b class="user">git commit</b></code></pre>

<p>これですべてのファイルがGitリポジトリで管理されたことになります。ここで、ビルドして生成された<code>hello_world</code>バイナリはリポジトリの管理に含めていないことに注意してください。このバイナリを実行できる環境は限られています。仮にこのGitリポジトリがネットワーク上に公開されていて、別の人がRHEL9 x86_64以外の環境でチェックアウトしたとき、実行できない意味のないファイルまでチェックアウトされてしまうことになります。それに、その人が<code>make</code>であらためてビルドし直したとき、Gitはファイルに変更が入ったものとみなしてしまいます。したがってここではビルドで生成されるものをGitリポジトリに含めないほうが賢明です。</p>

<p>最後にGitリポジトリのメタデータが格納されているディレクトリを確認しましょう。カレントディレクトリで<code>ls -a</code>を実行すると<code>.git</code>ディレクトリが存在しています。</p>

<pre><code><b class="user">ls -a</b>
.  ..  .git  Makefile  README  hello_world  main.c</code></pre>

<p>このディレクトリやその中身のファイルは削除したり編集したりしないでください。<code>git</code>コマンドによって自動的に変更されていき、このディレクトリ以下のファイルが変更されてもステージングの対象になったり差分が表示されることはありません。</p>

<h3>参考文献</h3>

<ul>
  <li>『<b><a href="https://progit-ja.github.io/">Pro Git</a></b>』Scott Chacon、Ben Straub 著、高木正弘、Yusuke Sato、harupong 訳（Apress、2015年）</li>
  <li>『<b>CVS CVSによるオープンソース開発</b>』Karl Fogel、Moshe Bar 著、でびあんぐる 監訳、竹内里佳 訳（オーム社、2002年）</li>
</ul>

<h2 id="test">Hello Worldをテストする</h2>

<p>これまでソースコードを書いたほかにコンパイルの自動化とこのプロジェクトについての説明となるREADMEを書いてきました。リモートリポジトリの設定はしていませんがソースツリーをGitリポジトリ化することで他者との共同作業もできるようになりました。</p>

<p>Hello Worldそのもののソースコードから少し離れたことをしてきましたが、ここではソースコードに焦点を戻すことにします。「Hello Worldが正常に動いているか」をどう保証するのかについて考えます。つまりHello Worldをテストするのです。</p>

<h3>ソフトウェアテスト</h3>

<p>なぜソフトウェアをテストをしなければならないのでしょうか。書いたコードを動かしてエンジニアの期待どおりに動くならそれでいいのではないでしょうか。</p>

<p>たしかに自分だけで、自己責任で使う範囲なら自身で意図したとおりにしかソフトウェアを動かさないでしょうし、バグがあったとしてもある程度許容はできるでしょう。しかしそのソフトウェアで利益を出そうとするケースを考えてみてください。せっかくお金を出して買ったソフトウェアが思い通りに動かなかったり、変なエラーを出して突然終了したり、出力される計算結果が間違っていたりしたらユーザはどう思うでしょうか？そのユーザはもう一度その会社からソフトウェアを買ったり、あるいはサブスクリプション契約を延長したいとは思わないでしょう。返金すら検討したくなるかもしれません</p>

<p>つまりソフトウェアの品質というのは、そのソフトウェアがもたらすユーザ体験や見かけだけではなく、バグやユーザが被る問題の少なさといった面も含まれるのです。品質を保証するためには体系的なソフトウェアテストが欠かせないということです。</p>

<p>では実際にソフトウェアテストとはどうおこなえばいいのでしょうか。古典『ソフトウェア・テストの技法』においてGlenford J. Myersはプログラムに対するテストを「<b>テストとは、エラーをみつけるつもりでプログラムを実行する仮定である</b>」（p.6）と定義しています。Myersは「プログラムにエラーがないことを証明する」（p.6）のがテストと決めてしまうと「プログラムをできるだけ失敗にみちびかないようなテスト・データを選択しようとするだろう」（p.6）と人間の心理的な側面を指摘し、エラーがないことを確認するテストよりもエラーを見つけることを目標としたテストのほうが結果としてエラーが見つかりやすくなりテストとしての価値が高いと論じています。つまり自分で作ったソフトウェアを壊すつもりでテストの手順を考えればいいのです。</p>

<h3>参考文献</h3>

<ul>
  <li>『<b>ソフトウェア・テストの技法 第2版</b>』Glenford J. Myers 著、長尾 真 監訳、松尾 正信 訳（近代科学社、2018年、第7刷）</li>
</ul>

<hr>
<footer><div style="text-align:center;padding-top:2em;padding-bottom:2em;"><a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/"><img src="https://i.creativecommons.org/p/zero/1.0/88x31.png" alt="CC0" /></a></div><p>To the extent possible under law, <a href="mailto:uki@e-yuuki.org">Yuuki Enomoto</a> has waived all copyright and related or neighboring rights to e-yuuki.org. This work is published from: Japan.</p></footer></article></body></html>
